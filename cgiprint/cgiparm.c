/*++++++++++++++
TODO: Name=&#929  ==> greek letter !!!
.IDENTIFICATION cgiparm.c
.LANGUAGE       C
.AUTHOR         Francois Ochsenbein [CDS]
.ENVIRONMENT
.KEYWORDS
.VERSION  1.0   27-Sep-1994
.VERSION  1.1   24-Sep-1996: Option -k
.VERSION  1.2   27-Jan-1997: Option -praw
.VERSION  1.3   02-Jun-1997: -log option
.VERSION  1.4   23-Oct-1997: Accept MULTIPART input generated by
		<FORM ENCTYPE="multipart/form-data" METHOD=POST ... >
.VERSION  1.5   07-Jan-2000: **McIntosh Problems **
		(no \n ... sigh!)
.VERSION  1.6   30-Jan-2000: **2000 Problem ! **
.VERSION  1.7   03-Apr-2000: -file option
.VERSION  1.8   11-May-2000: -pl or perl option
.VERSION  1.9   06-Jun-2000: -- option (just copy stdin, and log)
.VERSION  2.0   01-Sep-2000: Takes care of input
			" BookMark "  ==> Redirect (GET)
			"&=Echo"      ==> Redirect (GET) to Echo
			"&:pgm"	      ==> Define the redirect program
.VERSION  2.1   04-Oct-2000: Log also the UserAgent as $Agent=
.VERSION  2.2   20-Oct-2000: Accept -A option
.VERSION  2.3   04-Jul-2001: bug...
.VERSION  2.4   01-Aug-2001: -praw: replace \n by \v
.VERSION  2.41  23-Oct-2002: -sh a blank was missing!!
.VERSION  2.5   18-Feb-2004: -ilog (raw log), -cf (add comment about file names)
.VERSION  2.6   09-Feb-2007: &lt; &gt; etc
.VERSION  2.61  11-Feb-2007: Accept HEAD method
.VERSION  2.62  04-May-2007: Accept %16 as %26 (interpretation &)
.VERSION  2.7   26-Mar-2008: Accept argument -plus=-+ (is the + translated?)
.VERSION  2.71  25-Jul-2008: CONTENT_LENGTH not defined
.VERSION  2.72  31-Aug-2008: argument -file-prefix (default /tmp/p)
.VERSION  2.8   19-Sep-2008: accept Unicode variants for space & minus
.VERSION  2.81  26-Nov-2008: Revisited Unicode.
.VERSION  2.82  20-Apr-2009: Remove the <script
.VERSION  2.83  27-May-2009: non argument in sh mode
.VERSION  2.84  08-Sep-2009: skip the -plus argument
.VERSION  2.9   05-Feb-2010: multiple-level decoding
.VERSION  3.0   10-Feb-2010: Check binary / other file
.VERSION  3.1   28-Feb-2010: Management of old files.
				May have POST and QUERY_STRING together...
.VERSION  3.2   04-Jun-2010: No empty line (replace by "#void#)
.VERSION  3.3   27-Aug-2010: cleanup procedure improved
.VERSION  3.4   15-Oct-2010: /etc/ are REMOVED in arguments
.VERSION  3.5   11-Jul-2011: post + get simultaneously ==> save POST in a file
.VERSION  3.6   31-Dec-2011: Accept binary files
.VERSION  3.61  16-Jan-2012: ... but be sure the POST continues to work
.VERSION  3.62  04-Feb-2012: ... but be sure the POST continues to work
.VERSION  3.7   30-Apr-2012: unicode option
.VERSION  3.71  03-May-2012: remove empty files
.VERSION  3.72  09-May-2012
.VERSION  3.73  11-May-2012: Write a file ONLY IF no -a argument AND no GET
.COMMENTS       Simpler Interface than CGIParse !
---------------*/

#define VERSION  "3.73 (11-May-2012)"
#include <string.h>	/* Standard string manipulations */
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <ctype.h>
#include <fcntl.h>
#include <time.h>
#include <sys/stat.h>
#include <dirent.h>     /* Reading directorties */

#ifndef MAX_INPUT_FILENAMES	/* Keep the names of input files */
#define MAX_INPUT_FILENAMES 64
#endif

#ifndef LIFETIME		/* Life time of temporarry files */
#define LIFETIME 900  /* 15min */
#endif

#define ITEMS(a)        sizeof(a)/sizeof(a[0])
#define SEPARM		0177	/* Separator between parameters */

	/* Definition of interesting ENV variables */
static char *env[] = {
    "REQUEST_METHOD",
    "PATH_INFO",
    "QUERY_STRING",
    "PATH_TRANSLATED",
    "CONTENT_LENGTH",
    "CONTENT_TYPE",	/* For FILES */
    "HTTP_USER_AGENT"
} ;
static char *val[ITEMS(env)];

/* Could still be in input */
static char html_tags[] = "\
&amp;&\n\
&lt;<\n\
&gt;>\n\
&quot;\"\n\
&apos;\'\n\
&nbsp; \n\
&minus;=-\n\
";

#define REQUEST_METHOD	0
#define PATH_INFO	1
#define QUERY_STRING	2
#define PATH_TRANSLATED	3
#define CONTENT_LENGTH	4
#define CONTENT_TYPE	5
#define USER_AGENT	6

#define ENCODE_NONE  0		/* No encoding */
#define ENCODE_URL   1  	/* url-encoded */
#define ENCODE_MULTIPART 2	/* form...     */

	/* Options */
#define Bshell		1
#define Cshell		2
#define Perl		3
static char ostdin ;		/* -- option 	*/
static char ored ;		/* -r option 	*/
static char optA ;		/* -A option 	*/
static char oprint;		/* Bool Options: 1=asked, 2=praw, 4=if not -sh*/
static char osh, ocf, ov;	/* Bool Options	*/
static char okeep;		/* Keep headers */
static char *mime ;		/* -m option	*/
static char **apgm ;		/* -exec options*/
static char *rlogfile ;		/* -log  option	*/
static char *ilogfile ;		/* -ilog option	*/
static char *ulogfile ;		/* -ulog option	*/
static char *dirName ;		/* -d    option	*/
static char *fprefix ;		/* -f    option */
static char *dirfile ;		/* multipart   	*/
static char *opened_file ;	/* open_file   	*/
static char *itext ;		/* -i   option	*/
static char *remote_via ;
static char *remote_host ;
static char *remote_addr ;
static struct tm *T;
static char oname = 1;
static char mplus;		/* If -plus found */
static char keep_char[128] ;	/* Characters not converted	*/
static long t2000;
static int greek_opt = 3;	/* Default = 3-letter abbr. (Simbad) */
static char greek3[] = "\
??? alf bet gam del eps zet eta tet iot kap lam mu. nu. ksi omi \
pi. rho sig sig tau ups phi khi psi ome ??? ??? ??? ??? ??? ???";
static char *greek_letter[] = { "???",
  "alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta",
  "iota", "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi",
   "rho", "sigma", "sigma", "tau", "upsilon", "phi", "chi", "psi",
   "omega" };

static char *input_filenames[MAX_INPUT_FILENAMES+1];
static int  ninput_filenames;
static int cleaned = 0;		/* Cleaning temporary files: only when zero */

/* Expandable buffer */
typedef struct { int allocated, used ; char *buf ; } BUF ;

/* Default Extensions */
static char *mime_ext[] = {
   "/plain", 	".txt",
   "/xml", 	".xml",
   "/html", 	".htm",
   "/tab", 	".tsv",
   (char *)0
};
static char file_header[] = "\nContent-Type:";
#define starts_by(p, t)     strncmp(p,t,sizeof(t)-1)==0
#define starts_case(p, t)   strncasecmp(p,t,sizeof(t)-1)==0
#define Write(fno,text,len) { int _bytes = write(fno,text,len); \
    if(_bytes!=len) { fprintf(stderr, "#+++Wrote %d/%d bytes", \
       _bytes,(int)len); if(_bytes<0) perror(" *** "); }}

/*==================================================================
		Help
 *==================================================================*/
static void help()
{
static char text[] = "\
Usage: cgiparm [-noname] [-r] -[print|praw|csh|sh] [-k[chars]] [--] -g[0]\n\
   [-cf] [-A] [-a additional] [-d directory[%]|-file prefix] [-m mime_type]\n\
   [-log log_name] [-ulog strasbg_log] [-ilog input_log] [-i insert_text]\n\
   [-exec programs.. \\;]\n\
 Interprets the cgi-parameters of a cgi-script according to options [V2.5]:\n\
  -log lf: log the parameters into a file (except u-strasbg.fr) (%)\n\
 -ulog lf: log the parameters into a file (only   u-strasbg.fr) (%)\n\
 -ilog lf: log the raw input  into a file (%)\n\
  -d dir.: where to write new files (see below the % meaning)\n\
  -exec *: Execute the programs specified, until a semi-column is found\n\
  -f prf.: Prefix for files [default /tmp/cgi] followed by process-id\n\
      -g.: Greek letters and Unicode conversion: -g0=no conversion; \
           -g=full transliteration; g7=leave with '\\07' prefix; -g3=3-letter\n\
  -i text: insert the text (typically a program name) into the log file\n\
  -m type: write out the mime-type, e.g. -m text/html\n\
  -noname: ignore the parameter names (words preceding the = sign)\n\
   -print: write to standard output the parameters, one per line\n\
    -praw: write to standard output the parameters without interpretation\n\
     -csh: issue a command to define the argv array in C-shell\n\
      -pl: issue a command to define the ARGV array in Perl\n\
      -sh: issue a command to define the argv array in Bourne-shell\n\
           (e.g. via eval `cgiparm -sh`)\n\
      -cf: issue filenames as titles in the output, e.g. :-c=<<===myfile.dat\n\
       -r: interpret the &=pgm ... for Redirection\n\
       -k: either keep the file headers (the 'Content-Type') for '-k' alone;\n\
           or peficies the list of punctuation characters to keep\n\
           without conversion, e.g. -k% or -k+\n\
       --: the parameters are taken from stdin without translation\n\
       -A: extract the HREF=\"....\" from the argument (generally with -r)\n\
       -a: add the following parameters in the list\n\
\n\
(%) in file names, the % sign is interpreted as a formatting facility:\n\
   %Y %y %m %d %j %D = Dates ; %H %M %S %T = Time ;\n\
   %N = calling node         ; %P = Process number\n\
\n\
'-plus=-+' in the cgi parameters is interpreted as \"no '+' translation\"\n\
'content-type=' in QUERY_STRING (get) parameter supersedes the POST header\n\
" ;
    fprintf(stderr, "%s", text) ;
}

/*==================================================================*/
static int strloc(text, c)
/*++++++++++++++++
.PURPOSE  Locate specified character
.RETURNS  Index of located char
-----------------*/
  char *text;     /* IN: String to interpret */
  int  c;         /* IN: Char to look for */
{
  char *s;

    for ( s = text; *s; s++)      if (*s == c)    break;
    return(s-text);
}

/*==================================================================
		Time utilities
 *==================================================================*/
static char *date(op)
/*++++++++++++++++
.PURPOSE  Returns the date in various formats
.RETURNS  The result
.REMARKS  Options are  '.' = fully numeric YYYY.MM.DD,hh:mm:ss
	'D', 'H', 'M', 'S': up to specified level
	'/': 						DD/MM/DD
	'J':						JDdate
	The time since Jan. 1, 2000 is also kept in static t2000.
-----------------*/
  int op;	/* IN: Option  */
{
  static char buf[28];
  time_t t;
  double jd;
  char *p; int i;

    t = t2000 + (10957*86400) ;
    switch(op) {
    case '-': case 0:
    case 'D': case 'd': i = 10; goto case_ctime;
    case 'H': case 'h': i = 13; goto case_ctime;
    case 'M': case 'm': i = 16; goto case_ctime;
    case 'S': case 's': i = 19; goto case_ctime;
    case_ctime:
    	p = ctime(&t); p[7] = p[24] = 0; p[i] = 0;
    	sprintf(buf, "%s-%s-%s", p+20, p+4, p+8);
    	break;
    case ' ':
    	p = ctime(&t); p[7] = p[10] = p[24] = 0;
    	sprintf(buf, "%s %s %s", p+20, p+4, p+8);
    	break;
    case '/':
    	sprintf(buf, "%02d/%02d/%02d", T->tm_mday, T->tm_mon+1, T->tm_year%100);
    	break;
    case 'n': case 'N': case '.':	/* Numeric */
    	sprintf(buf, "%04d.%02d.%02d,%02d:%02d:%02d", T->tm_year, T->tm_mon+1,
    		T->tm_mday, T->tm_hour, T->tm_min, T->tm_sec);
    	break;
    case 'j': case 'J':			/* JDate   */
	jd = 2440587.5 + (t/86400.);	/* 2440587.5 = JD of Jan. 1, 1970 */
	sprintf(buf, "JD%.5f", jd);
	break;
    default:
    	p = ctime(&t); p[3] = p[7] = p[10] = p[19] = p[24] = 0;
    	sprintf(buf, "%s %s %s %s, %s", p, p+8, p+4, p+20, p+11);
    	break;
    }
    return(buf);
}

/*==================================================================
		String utilities
 *==================================================================*/

static int xval(c)
/*++++++++++++++++
.PURPOSE  Get the meaning of a char
.RETURNS  corresponding value
-----------------*/
  int c;	/* IN: Hexadigit to interpret */
{
    if (isxdigit(c)) {
	if (isdigit(c)) return (c - '0');
	if (isupper(c)) return (c - ('A' - 10));
	return (c - ('a' - 10));
    }
    return(0);
}

static char *i2a(val)
/*++++++++++++++++
.PURPOSE  Get the edition of a number
.RETURNS  corresponding value
-----------------*/
  int val;	/* IN: Value to edit */
{
  static char buf[16] ;
    sprintf(buf, "%d", val) ;
    return(buf) ;
}

static BUF *buf_alloc(bytes)
/*++++++++++++++++
.PURPOSE  Allocate a buffer
.RETURNS  ---
-----------------*/
  int bytes ;	/* IN: Size to allocate	*/
{
  BUF *b ;
    b = (BUF *)malloc(sizeof(BUF)) ;
    b->allocated = b->used = 0 ;
    b->buf = (char *)0 ;
    if (bytes > 1) {
	b->buf = malloc(bytes) ;
	b->allocated = bytes ;
    }
    return(b);
}

static void append(b, text)
/*++++++++++++++++
.PURPOSE  Append text to an expandable buffer
.RETURNS  ---
-----------------*/
  BUF *b ;	/* IN: Buffer 		*/
  char *text ;	/* IN: Text to append 	*/
{
  int len ;
    len = strlen(text);
    if ((b->used + len) >= b->allocated) {	/* Multiple of 512 */
	b->allocated = 1 + ((b->used + len + 1) | 511) ;
	b->buf = realloc(b->buf, b->allocated) ;
    }
    memcpy(b->buf + b->used, text, len+1) ;
    b->used += len ;
}

static void append1(b, c)
/*++++++++++++++++
.PURPOSE  Append 1 byte to expandable buffer
.RETURNS  ---
-----------------*/
  BUF *b ;	/* IN: Buffer	*/
  int c ;	/* IN: Byte 	*/
{
  char buf[2] ;
    buf[0] = c ;
    buf[1] = 0 ;
    append(b, buf) ;
}

static int is_encoded(char *buf, int len)
/*++++++++++++++++
.PURPOSE  Check a buffer is url_encoded
.RETURNS  ENCODE_URL (url-encoded) / ENCODE_NONE (plain text)
.REMARKS  Accepts spaces before/after the buffer
-----------------*/
{
  char *p=buf, *e; int pc=0, na=0;
    e = p + len;
    while(isspace(*p)) p++;
    while(isgraph(*p)) {
	if (*p == '%') { 	/* Yes, I have a % */
	    if (isxdigit(p[1]) && isxdigit(p[2])) {
	        pc++; p += 3;
	        continue;
	    }
	    /* Here a % not followed by hexa ==> ERROR */
	    pc = 0; break;
	}
	if (*p == '&') na++;
	 if (++p >= e) break;
    }
    while ((p<e) && isspace(*p)) p++;	/* Skip also \r\n\t\v */
    if (p<e) return(ENCODE_NONE);	/* Stopped by invalid character */
    return((pc>0)||(na>0) ? ENCODE_URL : ENCODE_NONE);
}

static int bin_len(char *text, int opt)
/*++++++++++++++++
.PURPOSE  Get the length of a binary inclusion
.RETURNS  0 if not a binary inclusion
.REMARKS  Inclusion is =<<====name#bytes\n... [\n]====name#bytes\n
	opt=0 ==> only bytes
	opt>0 ==> add also the strlen( =<<====name#bytes\n)
-----------------*/
{
  int n, bytes, len;
    n = strloc(text, '\n');
    if (ov) { int x;
	x = text[n]; text[n] = 0;
	printf("#...bin_len[%d](%s)", opt, text);
	text[n] = x;
    }
    len = n; if(text[n]) len++;
    for (--n; isdigit(text[n]); n--) ;
    if (text[n] == '#') n++;
    bytes = atoi(text+n);
    if (opt) {		/* Add all sizes */
	bytes += len;
        if (text[bytes]) {	/* Skip also the sentinel */
          char *t=text;
	    if (strncmp(text, "=<<==", 5) == 0) t = text+3;
	    if (text[bytes] == '\n') bytes++;
	    while (*t == text[bytes]) {
	        if (*t == '\n') break;
	        t++; bytes++;
	    }
        }
    }
    if (ov) printf(" => %dbytes\n", bytes);
    return(bytes);
}

static char *cpname(target, source)
/*++++++++++++++++
.PURPOSE  Copy the name to target, from source name="..."  filename="..."
.RETURNS  The delimiter for FILE, made of "====" followed by filename
.REMARKS  in MULTIPART
-----------------*/
  char *target;	/* MOD: where to append name=	*/
  char *source;	/* IN:  the Content-Disposition */
{
  static char delimiter[80] ;
  char *s, *e, *t, *n, *f ;
  int len ;

    s = source ;
    e = s + strloc(s, '\n') ;
    n = f = (char *)0 ;
    delimiter[0] = 0 ;
    s += strloc(s, ';') ;
    while (s < e) {
	if (*s == ';') s++ ;
	while (*s == ' ') s++ ;
	if (strncmp(s, "name=", 5) == 0) n = s+5 ;
	else if (strncmp(s, "filename=", 9) == 0) f = s+9 ;
    	s += strloc(s, ';') ;
    }

    t = target ;
    if (n && oname) {
	if (*n == '"') n++, e = n + strloc(n, '"') ;
	else for (e=n; isgraph(*e) && (*e != ';'); e++) ;
	while (n < e) *(t++) = *(n++) ;
	*(t++) = '=' ;
    }
    *t = 0 ;

    /* Save the delimiter */
    if (!f) return((char *)0) ;
    if (*f == '"') f++, e = f + strloc(f, '"') ;
    else for (e=f; isgraph(*e) && (*e != ';'); e++) ;
    len = e-f ;
    /* Note: len==0 is possible */
    if (len > (sizeof(delimiter)-5)) len = sizeof(delimiter)-5 ;

    delimiter[0] = delimiter[1] = delimiter[2] = delimiter[3] = '=' ;
    n = delimiter+4 ;
    strncpy(n, f, len) ; n[len] = 0 ;
    /* Keep enough room to store a length */
    if (strlen(delimiter)>=sizeof(delimiter)-15)
	delimiter[sizeof(delimiter)-15] = 0;
    return(delimiter) ;
}

static int get_multipart(char *buf, int len, char *boundary)
/*++++++++++++++++
.PURPOSE  Convert the MULTIPART arguments into "name=value"
.RETURNS  Number of arguments, each terminated by '\n'
.REMARKS  Newlines are replaced by TABs (for TEXT files only)
  char *buf;		-- MOD: String which is modified
  char *boundary ;	--  IN: The separator (NULL => take beginning)
-----------------*/
{
#define is_Mac   (eol == '\r')
static char default_text[] = "text/plain";
static char content_dispo[] = "\nContent-Disposition: " ;
  char *p, *ebuf, *q, *delimiter, *afile, eol;
  char *contents=0, *abegin=0, aboundary[128];
  int i, nargs, lb, bol=1; 		/* bol = 1 if at beginning of file */

    if (keep_char[0]) return(1); 	/* NO TRANSLATION */

    if (! boundary) boundary = "" ;
    delimiter = (char *)0 ; eol = '\n';
    lb = strlen(boundary) ;
    if ((lb==0) && (buf[0]=='-') && (buf[0]=='-')) { /* boundary = First line */
	boundary = buf+2;
	while (isgraph(boundary[lb])) lb++;
	if (lb>=sizeof(aboundary)) {
	    fprintf(stderr,
		"#***cgiparm-multipart: boundary of %d (>%d) bytes: <",
		lb, (int)sizeof(aboundary));
	    fwrite(boundary, 1, lb, stderr);
	    fprintf(stderr, ">\n");
	    lb = sizeof(aboundary);
	}
	strncpy(aboundary, boundary, lb);
	if (lb<sizeof(aboundary)) aboundary[lb] = 0;
	boundary = aboundary;
    }
    for (p=q=buf, ebuf=buf+len, nargs=0; p<ebuf; p++) {
	/*if (*p == '\n') { if (bol) *(q++) = '\n' ; bol = 1 ; continue; }*/
	if (contents) { 	/* Within a data file */
	    if ((p[0]=='\r') && (p[1]=='\n') && (p[2]=='-') && (p[3]=='-')
	      && (strncmp(p+4, boundary, lb) == 0)) {  /* End of current file */
		char *s;
		if (abegin) { unsigned int bytes;
		    bytes = (q-abegin);
		    abegin--;				/* abegin -> '\n' */
		    s = delimiter + strlen(delimiter); 	/* s -> \n */
		    while (bytes) {
			*--s = '0'|(bytes%10);
			*--abegin = *s;
			bytes /= 10;
		    }
		    while (*--s != '#') { *s = '0'; *--abegin = '0'; }
		    abegin = (char *)0;
		}
		if (!bol) *(q++) = '\n';
		for (i=0; delimiter[i]; i++) {
		    *(q++) = delimiter[i];
		    bol = delimiter[i] == '\n';
		}
		delimiter = contents = (char *)0;
		s = p + lb+4;
	        if ((s[0]=='-')&&(s[1]=='-'))   /* Last ending boundary */
	            p = s+2;
		else p++;
	        p--; /*bol=0;*/
		continue;
	    }
	    *(q++) = *p ;
	    continue;
	}
	/* Not within data... */
	if ((p[0]=='\r') && (p[1]=='\n')) p++;
	if (*p == eol) {
	    if (!bol) *(q++) = '\n';
	    bol = 1 ;
	    continue;
	}
	if (bol && lb && (p[0]=='-') && (p[1]=='-')
	    && (strncmp(p+2, boundary, lb) == 0)) {
	    p += lb+2;
	    if (delimiter) {	/* Embedded input <<==== */
	        strcpy(q, delimiter);
	        q += strlen(q) ;
		*(q++) = '\n';
		*q = 0;
	        delimiter = (char *)0 ;
	    }
	    contents = 0;
	    if ((p[0]=='-')&&(p[1]=='-')) {  /* Last ending boundary */
	        p += 1; bol = 0;
	        continue;
	    }
	    if (*p == '\r') {
	        if ((nargs==0) && (p[1]!='\n'))
	    	    eol = '\r';	/* ++++McIntosh: \n missing... */
	        if (is_Mac) *p = '\n';
	        else p++;
	    }
	    if (strncmp(p, content_dispo, sizeof(content_dispo)-1) != 0) {
	        /* Problem, missing Content-Disposition ! */
	        contents = default_text;
	        continue ;
	    }
	    p++ ;
	    if (ov) {
	        printf("#...Multipart, found <") ;
	        i = strloc(p, eol) ;
	        if (p[--i] != '\r') ++i ;
	        fwrite(p, 1, i, stdout) ;
	        printf(">\n") ;
	    }
	    if (bol==0) *(q++) = '\n';  /* terminate preceding argument */
	    afile = q;			/* Keep e.g. -c=<<===   */
	    delimiter = cpname(q, p) ; bol=0;
	    p += strloc(p, eol) ;		/* Skip line 		*/
	    q += strlen(q) ;		/* Position at end of name= */
	    if (delimiter) {
	        if (ninput_filenames < MAX_INPUT_FILENAMES)
	    	input_filenames[ninput_filenames++] = afile;
	        strcpy(q, "<<"), q += 2;
	        /* V3.1: remove Content-Type */
	        if (strncmp(p, file_header, sizeof(file_header)-1) == 0) {
	    	    contents = p+sizeof(file_header)-1;
	    	    while (*contents == ' ') contents++;
	    	    i = strloc(p+1, eol)+1;
	    	    if ((p[i] == '\n') && (iscntrl(p[i+1])))
	    	        p += i;
	    	    /* For binary Contents, use a delimiter
	    	       "file=<<====FileName#bytes" 
		       V3.72: Always do this with -d option
		    */
	    	    if (dirName || strncmp(contents, "text", 4)) {
			abegin = delimiter + strlen(delimiter);
			*(abegin)++ = '#';
			sprintf(abegin, "%d", (int)(ebuf-p));
	    	    }
	        }
	        strcpy(q, delimiter);
	        q += strlen(q) ;
	        *(q++) = '\n' ; *q = 0;
		if (abegin) abegin = q;
	    }
	    nargs++ ;
	    if (ov>1) {
	        printf("#...Multipart, remains <") ;
	        for (i=0; i<4; i++) printf("%02x ", p[i]) ;
	        printf(">\n") ;
	    }
	    if (*p == '\r') p++ ;
	    if (*p == '\n') p++ ;
	    if (*p == '\r') p++ ;
	    if (*p == '\n') p++ ;
	    p-- ;
	    continue ;
	}
	*(q++) = *p ;
	bol = 0;
	/*if (delimiter) *(q++) = '\n' ; */
    }

    /* Terminate the interpretation */
    if (!bol) *(q++) = '\n' ;
    if (delimiter) {
	strcpy(q, delimiter),
	q += strlen(q);
	if (q[-1] != '\n') *(q++) = '\n' ;
	delimiter = (char *)0 ;
    }
    *(q++) = 0 ;
    *(q++) = 0 ;
    *q = 0 ;

    return(nargs) ;
}

static int put_unicode(char *text, int u)
/*++++++++++++++++
.PURPOSE  Write (to text) the equivalent of unicode char u
.RETURNS  Number of bytes written out (0, 1, 2).
.REMARKS  Conversions include: nbsp --> ' '
          minus [mn]sans variations --> '-'
          index + epos              --> number
          Non-interpretable chars --> ~
    Greek letters are here coded as \7 +
    =a   b   c   d   e   f   g   h   i   j   k   l   m   n
    alf bet gam del eps zet eta tet iot kap lam mu. nu. xi.
    =o   p   q   r   s   t   u   v   w   x   y   z
    omi pi. rho sig sig tau ups phi chi psi ome
-----------------*/
{
static char latin1[] = /* Unicode 00A0 .. 00BF; ~ are not replaced */
/* 0123456789abcdef01234 56789abcdef */
  " ~~~~~|~~~~~~-~~ ~23'\6~.,1 ~~~~~";   /* Replace degree by blank, \6=mu */
static char U2000[] /* U+2000 -> 208F = Punctuation + Expo + Indice */ = "\
                \
------|='',`\"\"\"\"\
==.>....        \
~'\"~`\"~^<>x~~-_\
~~-/[]~~~~~~~*;\
~%>_*~~~x:~+|| \
   \0\0\0\0\0\0\0\0\0\0\0\0\0\
0i23456789+-=()n\
0123456789+-=()";
static char U2200[] = /* Operators
  220x = . C d . . phi Delta ,abme in not.in in ni not.ni ni sq Pi
  221x = U Sigma - -+ .+ / \ * deg cdot sqrt cbrt c4rt prop. inf. perp
  222x = ......
  223x = ...
  225x = ...
  226x  2264(<=) 2265(>=)
00112233445566778899aabbccddeeff */ "\
 .C d  . .O D  . . . . . . .. P \
U S - -+.+/ \\ * o . V V3V4 .if .\
 . . .| /||| .^ v  .U S SS . . .\
 . . . . . .: ::.--: . .~ ~ ~ ~ \
 . .=~=~!==~!=!=~~!~=~~~=~ . . .\
============ . . . . . . . . .?=\
!===!===<=>=<=>=<=>=<<>>()!~!<!>\
!<!><~>~ . . . . . .< > <=>=<~>~\
>=<= . . . . . . . . . . . . . .\
 . . .P U o+o-oxo/o.ooo*o=o-+ - \
x .  . . . . . . . . . . . . . .\
 . .<--><-->-----o+ T V  . . . .\
 .V  .U  .. * *  . . . . .=~ . .\
 . . . . . . . . . . . .<=>=<=>=\
 . . . . . . . . . . . . . . . .\
/ \\  . . . . . . . . . . . . . ." ;

    if (u < 128) {  /* Simple ascii */
        *text = u;
        return(1);
    }
    else if (u < 256) {
        if ((u&0xe0) == 0xa0) { /* U+00A0 .. U+00BF */
            *text = latin1[u&0x1f];
            if (*text == '~') *text = u;
            return(1);
        }
        *text = u;
        return(1);
    }
    else if ((u>=0x391) && (u<0x3c9)) { /* Greek alphabet */
        u += ('a' - 0xb1);              /* 03xb1 = alpha */
        text[0] = '\7';
        text[1] = u&0x7f;
        return(2);
    }
    else if ((u>=0x2000) && (u<=(0x2000+sizeof(U2000)))) { /* Math1 */
        u = U2000[u&0xff];
        if (u) { *text = u; return(1); }
    }
    else if ((u>=0x2200) && (u<=(0x2200+2*sizeof(U2200)))) { /* Math */
      char *p = text;
	u = (u&0xff)<<1;
	if (isgraph(U2200[u])) *(p++) = U2000[u++];
	if (isgraph(U2200[u])) *(p++) = U2000[u++];
        return(p-text);
    }
    return(0);
}

static int ht_arg(buf)
/*++++++++++++++++
.PURPOSE  Convert the argument (not multipart).
	%xx -> ascii symbol
	&#...;  not kept
.RETURNS  Number of arguments, each terminated by '\n'
.REMARKS  Newlines are replaced by TABs
-----------------*/
  char *buf;	/* MOD: String which is modified */
{
  static int callno = 0;
  char *p, *q, *t, c;
  int  i, n;
  int recu = 0;				/* Number of recursive codings */

    if (!buf) return(0);
    if (!*buf) return(0);
    if (keep_char[0]) return(1); 	/* NO TRANSLATION */
    ++callno;
    if (ov) printf("#...Call#%d: ht_arg(%s)\n", callno, buf);
    c = 0;		/* Empty buffer means 0 parameter */
    p=q=buf;
    if (strncmp(buf, "-plus=-", 7) == 0) {	/* V2.7, V2.84  */
	p = buf+7;
	if (*p == '+') keep_char['+'] = 1, p++;
	else if (*p == '%') {
	    mplus = 1;
	    /* Recursive encodings give e.g. -plus=-%252b */
	    for (++p; (p[0] == '2') && (p[1] == '5'); p += 2) recu++;
	    /* Here in principle I should have  '2b' */
	}
	/* Locate the end of the argument */
	while (*p) {
	    if (*p == '&') {
		if (strncmp(p, "&amp;", 5) == 0) p += 5;
		else p++;
		break;
	    }
	    if ((p[0] == '%') && (p[1] == '2') && (p[2] == '6')) {
		p += 3;
		break;
	    }
	    p++;
	}
    }
    for (n=0; *p; p++, q++) {
	c = *p;
	if (!keep_char[c]) switch(c) {
	case '+': *q = ' ';
	    continue;
	case '%': *q = 0;	/* Hexa representation */
	    /* Recursive encodings done at the end */
	    /* for (i=0; (i<recu)&&(p[1]=='2')&&(p[2]=='5'); i++) p += 2; */
	    if (isxdigit(p[1])) ++p, *q = (*q<<4) | xval(*p);
	    if (isxdigit(p[1])) ++p, *q = (*q<<4) | xval(*p);
	    if (*q == '\n') *q = '\t';
	    else if (*q == '\26') 	/* V2.62 */
		*q = '&';
	    continue;
	case '&': 			/* & separates arguments */
	    if (p[1] == '#') {		/* Symbol not replaced... */
		if (p[2] == 'x')
		     for (i=3; isxdigit(p[i]); i++) ;
		else for (i=2; isdigit(p[i]); i++) ;
		if (p[i] == ';') {	/* Unicode entity: keep it! */
		    while (--i>0) *(q++) = *(p++);
		    *q = *p;
		    continue;
		}
	    }
	    t = (char *)0;
	    for (i=1; (i<8) && (p[i] != ';') && p[i]; i++) ;
	    if (p[i] == ';') {		/* HTML tag */
		p[i] = 0;
		t = strstr(html_tags, p);
		p[i] = ';';
	    }
	    if (t) {			/* HTML tag */
		p += i;
		if (t != html_tags) { 	/* &lt; etc */
		    *q = t[i+1] ;
		    continue;
		}
	    }
	    /* NO BREAK -- & found!  */
#if 0
	    if (strncmp(p, "&amp;", 5) == 0) /* most likely a bad parser */
		p += 4 ;
#endif
	case '\v':
	    *q = '\n';
	    n++;
            if (strncmp(p+1, "-plus=-+", 8) == 0)	/* V2.7   */
	        keep_char['+'] = 1;
	    continue;
	case '\n':
	    *q = '\t';
	    continue ;
	}
	else if (c == '\n') n++;
	*q = *p;
    }
    if ((c == '&') && (!keep_char[c])) q--, n--;
    *q = 0;
    n++;
    while (--recu>=0) {
	n = ht_arg(buf);
    }
    return(n);
}

int strumb1(char *text)
/*++++++++++++++++
.PURPOSE  Convert some Unicode multi-byte extensions + &#...; entities
.RETURNS  Number of substitutions
.REMARKS  text is MODIFIED!
    Conversions include: nbsp --> ' '
    minus [mn]sans variations --> '-'
    index + epos              --> number
Multibyte extension is
    110xxxxx 10xxxxxx           --> U0080 .. U07FF  (11 bits)
    1110xxxx 10xxxxxx 10xxxxxx  --> U0800 .. UFFFF  (16 bits)
Not taken into account:
    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (U10000 .. U10FFFF)
Note: Greek letters = x0391 .. x03a9 (sigma duplicated) (uppercase)
                      x03b1 .. x03c9 (sigma duplicated) (lowercase)
           Exponent = x2070 .. x2079 (1=x00b9 2=x00b2 3=x00b3)
           Index    = x2080 .. x2089
    Greek letters are here coded as \7 +
    =a   b   c   d   e   f   g   h   i   j   k   l   m   n
    alf bet gam del eps zet eta tet iot kap lam mu. nu. xi.
    =o   p   q   r   s   t   u   v   w   x   y   z
    omi pi. rho sig sig tau ups phi chi psi ome
    (or \6 = mu)
    Uppercase possible
-----------------*/
{
  char *p, *t;
  int n=0, u, bol=1, nb;
    p = t = text;
    while (*t) {
	if ((t[0]&0x80) == 0) { /* Simple ascii */
	    if (bol) { char *s; int len;	/* Verify a file embedded */
	        for (s=t; isgraph(*s); s++) {
		    if (starts_by(s, "=<<==")) break;
		}
		if ((*s == '=') && (len = bin_len(s,1))) {
		    /* Yes, binary input */
		    len += (s-t);
		    if (n) memmove(p, t, len);
		    p += len; t += len;
		    continue;
		}
	    }
	    if ((t[0] == '&') && (t[1] == '#')) { int i;
		if (t[2] == 'x')
		    for (i=3, u=0; isxdigit(t[i]); i++) u = (u<<4) | xval(t[i]);
		else for (i=2, u=0; isdigit(t[i]); i++) u = (u*10) + (t[i]&0xf);
		if (t[i] == ';') { 	/* Yes, UTF! */
		    if ((nb = put_unicode(p, u))) { /* Symbol understood */
			p += nb;
		        t += i+1;
			n++;
		        continue;
		    }
		}
	    }
	    bol = (*t == '\n');
	    if (n) *p = *t;
	    p++; t++;
	    continue;
	}
	if (((t[0]&0xe0) == 0xc0) && ((t[1]&0xc0) == 0x80)) {
	    /* 2-byte Unicode */
	    u = ((t[0]&0x1f)<<6) | (t[1]&0x3f);
	    if ((nb = put_unicode(p, u))) {
	        p += nb;
	        n++;
	    }
	    else {
		fprintf(stderr,
		    "#+++cgiparm: Unicode [&#x%04X] replaced by &?\n", u);
		*(p++) = '&'; *(p++) = '?';
	    }
	    t += 2;
	    continue;
	}
	else if (((t[0]&0xf0) == 0xe0) && ((t[1]&0xc0) == 0x80)
	                               && ((t[2]&0xc0) == 0x80)) {
	    /* 3 byte-unicode */
	    u = ((t[0]&0xf)<<12) | ((t[1]&0x3f)<<6) | (t[2]&0x3f);
	    if ((nb = put_unicode(p, u))) {
	        p += nb;
		n++;
	    }
	    else {
		fprintf(stderr,
		    "#+++cgiparm: Unicode [&#x%04X] replaced by &??\n", u);
		*(p++) = '&'; *(p++) = '?'; *(p++) = '?';
	    }
	    t += 3;
	    continue;
	}
	else if ((t[0]&0xff) >= 160) {  /* 8-bit UTF codes */
	    u = t[0]&0xff;
	    p += put_unicode(p, u);
	    t++; n++;
	    continue;
	}
	/* No modification */
	if (n) *p = *t;
	p++; t++;
    }
    if (n) *p = 0;	/* Terminate string */
    return(n);
}

static char *greek_subs(char *buf)
/*++++++++++++++++
.PURPOSE  Convert the Greek characters (marked by '\7', or '\6'=mu)
.RETURNS  A (not always new) piece of memory with substituted text.
-----------------*/
{
  char *abuf, *p, *q, *g;
  int i, bol, greek_len;
    /* Convert the Greek letters */
    if ((greek_opt == 0) || (greek_opt == 7)) return(buf);
    for (i=0, p=buf, bol=1; *p; p++) {
	if (bol) { char *s; int len;	/* Verify a file embedded */
	    for (s=p; isgraph(*s); s++) {
		if (starts_by(s, "=<<==")) break;
	    }
	    if ((*s == '=') && (len = bin_len(s,1))) {
		/* Yes, binary input */
		p = s+len-1;
		continue;
	    }
	}
	bol = (*p == '\n');
	if ((*p&0xfe)==6) i++;
    }
    if (i == 0) return(buf);
    if (ov) printf("#...There are %d Greek letters to convert\n", i);
    greek_len = greek_opt==3 ? 3 : 7 ;
    q = abuf = malloc(strlen(buf)+ i*greek_len + 1);
    for (p=buf, bol=1; *p; p++) {
	if (bol) { char *s; int len;	/* Verify a file embedded */
	    for (s=p; isgraph(*s); s++) {
		if (starts_by(s, "=<<==")) break;
	    }
	    if ((*s == '=') && (len = bin_len(s,1))) {
		/* Yes, binary input */
		len += (s-p);
		memmove(q, p, len);
		q += len; p += len-1;
		continue;
	    }
	}
	bol = (*p == '\n');
        if (*p == '\7') i = (*++p);
	else if (*p == '\6') i = 'a'+12;  /* mu = 12the letter */
	else { *(q++) = *p; continue; }
	/* Here I have a greek letter */
	i &= 0x1f;
    	if (i >= ITEMS(greek_letter)) i = 0;
    	if (greek_len == 3)  /* Simbad 3-letter transliteration */
    	    g = greek3 + (i*4);
    	else                 /* Full-text transliteration */
    	    g = greek_letter[i];
    	*q = *g; if (isupper(*p)) *q = toupper(*g);
    	++q; g++;
    	while (isgraph(*g)) *(q++) = *(g++);
    }
    *q = 0;
    return(abuf);
}

static int check_buf(char *buf, int opt)
/*++++++++++++++++
.PURPOSE  Check the input : refuse /etc/, <script
.RETURNS  0=OK / 1=changes / 2=security problems
.REMARKS  If opt&1: Replace <script by #script
-----------------*/
{
  char *p, *s, *q;
  int len, minsize=7, bytes, status=0, x;
    for (p=buf; *p; p+=len) {
	len = strloc(p, '\n');
	if (len<minsize) { if(p[len]) len++; continue; }
	x = p[len]; p[len]=0;
	s = strstr(p, "/etc/");
	q = strchr(p, '<');
	p[len]=x; if(x) len++;
	if (s) return(2);
	if (!q) continue;
	if (starts_case(q, "<script")) {
	    status |= 1;
	    if (opt&1) *q = '#';
	}
	else if (q[1] == '<') {	/* File embedded? */
	    --q;
	    if ((strncmp(q, "=<<====", 7)==0) && (bytes = bin_len(q,1))) {
		p = q+bytes;
		len = 0;
		continue;
	    }
	}
    }
    return(status);
}

char *basename(name)
/*++++++++++++++++
.PURPOSE  Locate the filename (remove directory definitions)
.RETURNS  The last part
-----------------*/
  char *name;     /* IN: String to interpret */
{
  static char ok[128] ;
  char *s; int i ;
    /* Initialize the list of available chars */
    if (!ok['a']) {
	for (i='0'; i<= '9'; i++) ok[i] = i ;
	for (i='A'; i<= 'Z'; i++) ok[i] = i ;
	for (i='a'; i<= 'z'; i++) ok[i] = i ;
	ok['.'] = '.' ;
	ok['-'] = '-' ;
	ok['_'] = '_' ;
	ok['#'] = '#' ;
    }
    for (s=name+strlen(name)-1; (s>=name) && isascii(*s) && ok[*s]; s--) ;
    return(++s) ;
}

int strbloc(text, c)
/*++++++++++++++++
.PURPOSE  Locate specified character backward
.RETURNS  Index of located char / -1 if not found
-----------------*/
  char *text;     /* IN: String to interpret */
  int  c;         /* IN: Char to look for */
{
  char *s;

    for (s=text+strlen(text); --s >= text; )  if (*s == c)    break;
    return(s-text);
}

static int tr_optA(buf)
/*++++++++++++++++
.PURPOSE  Keep only the arguments from HREF= in buf
.RETURNS  0 / -1
.REMARKS  <!-- ... --> Comments are ignored
-----------------*/
  char *buf;	/* MOD: String which is modified */
{
  char *p, *q, *a, c;
  int n = 0;
    /* Remove first the Comments */
    p = q = buf ;
    while (a = strstr(p, "<!--")) {
	strncpy(q, p, a-p) ; q += (a-p) ;
	p = strstr(a, "-->") ;
	if (!p) {
	    fprintf(stderr, "****Unclosed Comment: %s\n", a) ;
	    n = -1 ;
	}
	p += 3 ;
	while (isspace(*p)) p++ ;
    }
    if (p != q) strcpy(q, p) ;

    /* Find now the HREF=\" */
    p = q = buf ;
    while (a = strstr(p, "HREF=\"")) {
	p = a+strloc(a, '?') ;
	if (*p) p++ ;
	while (*p && (*p != '"')) {
	    *q = *p;
	    if (strncmp(p, "&amp;", 5) == 0) p += 4 ;
	    p++; q++ ;
	}
	*q = 0 ;
    }

    return(n) ;
}

static int clean_files()
/*++++++++++++++++
.PURPOSE  Clean the unsued files
.RETURNS  How many files /leaned up (0 = not examined)
.REMARKS  Files not accessed since LIFETIME are removed
-----------------*/
{
  static char *master, *subprefix;
  static char master_text[] = "#...cleanup(cgiparm)\n";
  static int subprefix_len, subprefix_max;
  DIR *dirp; struct dirent *dire;
  struct stat buf;
  time_t now, t;
  int k, age, o_opt, nf=0;
  char *p;

    if (!master) {
	if (!fprefix) fprefix = "";
	master = malloc(strlen(dirfile) + strlen(fprefix) + 32);
	strcpy(master, dirfile); p = master + strlen(master);
	*(p++) = '/'; subprefix = p;
	strcpy(p, fprefix);
	while (*p) { if (isdigit(*p)) break; p++; }
	if (isdigit(*p)) *p = 0;
	subprefix_len = strlen(subprefix);
	subprefix_max = subprefix_len + 16;
	if (ov) fprintf(stderr,
		"#...cgiparm(cleanup): dirfile=%s, master=%s, subprefix=%s\n",
		dirfile, master, subprefix);
    }

    /* If master file accessed during last 15min, no nead to check */
    o_opt = O_WRONLY;
    strcpy(subprefix+subprefix_len, "=0");
    if (stat(master, &buf) < 0) {    /* Master file not existing ? */
	fprintf(stderr, "#+++cgiparm(cleanup): ");
	perror(master);
	memset(&buf, 0, sizeof(buf));
	o_opt |= O_CREAT;
    }
    now = time((time_t *)0);
    age = now - buf.st_atime;
    if (ov) fprintf(stderr, "#...cgiparm(cleanup): age(%s)=%d\n", master, age);
    if (age < LIFETIME) {
	if (ov) fprintf(stderr,
		"#===cgiparm(cleanup): age(master)=%d (%s)\n",
		age, "no exam");
	return(0);
    }

    /* Write the master file to change its time */
    k = open(master, o_opt, -1);
    if (k<0) {
	fprintf(stderr, "#***cgiparm(cleanup): ");
	perror(master);
    }
    else {
	Write(k, master_text, sizeof(master_text)-1);
	close(k);
    }

    /* Loop on files */
    if (ov) fprintf(stderr,
	    "#---cgiparm(cleanup): look for old files in: %s\n",
	    dirfile);
    dirp = opendir(dirfile);
    if (!dirp) {
	fprintf(stderr, "#***cgiparm(cleanup): Can't opendir ");
	perror(dirfile);
	return(-1);
    }
    while((dire = readdir(dirp))) {
	k = strlen(dire->d_name);
	if ((k<=subprefix_len) || (k>subprefix_max))
	    continue;
	if (strncmp(dire->d_name, subprefix, subprefix_len) != 0)
	    continue;
	if (ov) fprintf(stderr,
		"#...cgiparm(cleanup): file %s ", dire->d_name);
	strcpy(subprefix, dire->d_name);
	if (stat(master, &buf) == 0) {
	    if (!S_ISREG(buf.st_mode)) {
		if (ov) fprintf(stderr, "(not a file)\n");
		continue;
	    }
	    age = now - buf.st_atime;
	    if (age < LIFETIME) {
		if (ov) fprintf(stderr, "age=%ds (too young)\n", age);
		continue;
	    }
	    if (ov) fprintf(stderr, "age=%ds [remove]\n", age);
	    if (unlink(master) < 0) {
	        fprintf(stderr, "#+++cgiparm(cleanup): error remove ");
	        perror(master);
	    }
	    else nf++;
	}
    }
    return(nf);
}


static FILE *open_file(char *name)
/*++++++++++++++++
.PURPOSE  Open a file (append mode)
.RETURNS  The opened file / NULL
.REMARKS  The name of the file is kept in opened_file
	name NULL ==> default pid
	name ""   ==> increase
	the "#" in name is removed.
-----------------*/
{
  static int bytes = 0;	/* Allocated    */
  static int fno = 0 ;	/* File counter */
  int suffix = 0;	/* Bytes for suffix */
  int addx = 0;	    /* in case of collision */
  FILE *f ;
  char *p ;
  int i ;

    /* Which file name ? */
    if (ov) printf("#...cgiparm(open_file): name=%s\n", name ? name : "(nil)") ;
#if 0
    if (!name) {
	name = filename ;
	sprintf(name, "p%05d", getpid()) ;
    }
    if (!*name) {
	name = filename ;
	sprintf(name, "p%05d-%d", getpid(), ++fno) ;
    }
#else
    if (!name)  name = "";
    if (*name == '#') name = "";
    if (!*name) {
	if (cleaned==0) { clean_files(); cleaned++; }
	name = fprefix;
	suffix = 12;
    }
    if (!name) { 
	name = "f"; 
	suffix = 12;
    }
#endif

    /* Allocate bytes to save the name of the file */
    i = strlen(name) + strlen(dirfile) + suffix + 8 ;
    if (bytes < i) {
	bytes = (i|15) + 1 ;
	if (opened_file) free(opened_file) ;
	opened_file = malloc(bytes) ;
    }
    strcpy(opened_file, dirfile) ;
    p = opened_file + strlen(opened_file) ;
    *(p++) = '/' ;
    strcpy(p, name); p += strloc(p, '#'); *p = 0;
    if (suffix) { sprintf(p, "-%d", ++fno); p += strlen(p); }
    while ((i = open(opened_file, O_EXCL|O_CREAT, 0666)) < 0) {
	if(errno != EEXIST) {
	    fprintf(stderr, "#***cgiparm(open_file): ");
	    perror(opened_file);
	    return((FILE *)0);
	}
	if (ov) fprintf(stderr,
		"#+++cgiparm(open_file): failed create: %s\n", opened_file);
	sprintf(p, ",%x", ++addx);
    }
    close(i);
    f = fopen(opened_file, "w") ;
    if (!f) {
	fprintf(stderr, "#***cgiparm(open_file): ") ;
	perror(opened_file) ;
    }
    if (ov) printf("#---cgiparm(open_file): name=%s\n", opened_file);
    return(f) ;
}

static char *edited_name(char *name)
/*++++++++++++++++
.PURPOSE  Interpret items like '%N' in name
.RETURNS  A new piece of memory with interpreted name
.REMARKS  Knows %Y %y %m %d %H %M %S %T %j
	and %P=pid  %N=Node %V=Version
-----------------*/
{
  char *p, *t, *a ;
  int i ;
    for (p=name, i=strlen(name); *p; p++) {
	if (*p != '%') continue ;
	if (*++p == 'N') i += strlen(remote_host) ;
	else i += 10 ;
    }
    a = malloc(i+8) ;
    for (p=a, t=name; *t; p += strlen(p), t++) {
	if (*t == '%') switch(*++t) {
	  case 'y': sprintf(p, "%02d", T->tm_year%100);	continue ;
	  case 'Y': sprintf(p, "%d", T->tm_year); 	continue ;
	  case 'm': sprintf(p, "%02d", T->tm_mon+1); 	continue ;
	  case 'd': sprintf(p, "%02d", T->tm_mday); 	continue ;
	  case 'D': sprintf(p, "%d%02d%02d",
	      T->tm_year, T->tm_mon+1, T->tm_mday); 	continue ;
	  case 'j': sprintf(p, "%03d", T->tm_yday+1); 	continue ;
	  case 'J': sprintf(p, "%u", (int)t2000); 	continue ;
	  case 'H': sprintf(p, "%02d", T->tm_hour); 	continue ;
	  case 'M': sprintf(p, "%02d", T->tm_min); 	continue ;
	  case 'S': sprintf(p, "%02d", T->tm_sec); 	continue ;
	  case 'T': sprintf(p, "%02d%02d%02d",
		T->tm_hour, T->tm_min, T->tm_sec); 	continue ;
          case 'p':
	  case 'P': sprintf(p, "%05d", getpid()); 	continue ;
	  case 'N': strcpy(p, remote_host);	 	continue ;
	}
	p[0] = *t; p[1] = 0 ;
    }
    return(a);
}

static char *create_dir(name)
/*++++++++++++++++
.PURPOSE  Create a new directory, from template
.RETURNS  The name of the directory created.
.REMARKS  Knows %Y %y %m %d %H %M %S %T %j
	and %P=pid  %N=Node %V=Version
-----------------*/
  char *name ;	/* IN: Name of directory to create */
{
  char *p, *a ;
  int i ;
    cleaned++;	/* never clean the files (unique directory) */
    a = edited_name(name);
    if (ov) printf("#...Will create directory: %s\n", a) ;
    if (mkdir(a, -1) == 0) return(a) ;
    if (ov) printf("----mkdir(%s) FAILED, errno=%d (%s)\n",
	 a, errno, strerror(errno)) ;
    if (errno != EEXIST) return((char *)0) ;
    p = a + strlen(a) ;
    *(p++) = ':' ;
    for (i=1; i <= 999; i++) {
	sprintf(p, "%03d", i) ;
	if (mkdir(a, -1) == 0) return(a) ;
        if (ov) printf("----mkdir(%s) FAILED, errno=%d (%s)\n",
	    a, errno, strerror(errno)) ;
	if (errno != EEXIST) return((char *)0) ;
    }
    return((char *)0) ;
}

static void redirect_if(char *buf)
/*++++++++++++++++
.PURPOSE  Examine the Buffer. If redirection is asked
		- either with " Bookmark"
		- or with "&="
	  write out the Redirection Header
.RETURNS  ---
-----------------*/
{
  char *p, *pgm, *cmd, c, sep;
  int n ;

    if (*buf) return;
#define DEBUG_REDIRECT 0
#if DEBUG_REDIRECT
    FILE *f ;
    f = fopen("/tmp/redirect_if", "w") ;
    if (!f) f = stderr ;
    fprintf(f, "Contents of redirect_if buffer:\n%s\n", buf) ;
#endif
    /* Check first if there is any redirection ? */
    pgm = (char *)0 ;
    cmd = getenv("SCRIPT_NAME") ;
    p = buf ;
    while (*p)  {
        if (*p == '\n') { p++ ; continue ; }
	/* &= supplies the prograp to call
	   &=: the DEFAULT program to set
	*/
	if ((p[0] == '&') && (p[1] == '=')) {
	    if (p[2] == ':') cmd = p+3 ;
	    else { pgm = p+2 ; break ; }	/* First Priority */
	}
	else if (strncmp(p, " Bookmark", 9) == 0) {
	    pgm = cmd ;
	}
	p += strloc(p, '\n') ;
    }
    if (!pgm) return ;

#if DEBUG_REDIRECT
    fprintf(f, "\nReady to start Moved Message:\n%s\n", buf) ;
#endif

    /* Write out now the Redirect */
    printf("Status: 302 Moved Temporarily\r\nLocation: ") ;

    /* Write out the full Anchor */
#if 0
    if (p = getenv("SERVER_NAME")) printf("http://%s", p) ;
    if (p = getenv("SERVER_PORT")) {
        n = atoi(p) ;
	if (n != 80) printf(":%d", n) ;
    }
#endif
    if (!pgm) pgm = getenv("SCRIPT_NAME") ;
    if (!pgm) pgm = "" ;
    if (*pgm != '/') {	/* Relative path --> Absolute */
	p = getenv("SCRIPT_NAME") ;
	if (!p) p = "" ;
	n = strbloc(p, '/') ;
	while (--n >= 0) putchar(*p), p++ ;
	putchar('/') ;
    }
    c = strloc(pgm, '\n') ; p = pgm + strloc(pgm, '\n') ;
    c = *p; *p = 0 ;
    printf("%s", pgm) ;
    *p = c ;
    sep = '?' ;

    /* Write out the GET values.
       Ignore the lines without values (=)
       Ignore the lines starting by &
       V2.7: add the argument "-plus=-+"
    */
    cmd = buf ;
    if (keep_char['+']) {		/* Added V2.7 */
	putchar(sep) ; sep = '&' ;
	printf("-plus=-+");
    }
    for (cmd=buf; *cmd; cmd += strloc(cmd, '\n')) {
	while (*cmd == '\n') 	/* Ignore Empty line */
	    cmd++ ;
	if (*cmd == '&') 	/* Ignore This  line */
	    continue ;
	if (strncmp(cmd, " Bookmark", 9) == 0)
	    continue ;

	/* Look for a line without value */
	for (p = cmd; *p && (*p != '=') && (*p != '\n'); p++) ;
	if ((p[0] == '=') && ((p[1] == '\n') || (p[1] == 0)))
	    { cmd = p ; continue ; }

	/* Write the argument in GET mode */
	putchar(sep) ; sep = '&' ;
	for (p = cmd; *p && (*p != '\n'); p++) switch(*p) {
          case '\t': case '\v':
            printf("%%%02x", '\n') ; continue ;
          case '&': case '/':
          case ' ': case '+': case '%': case '*': case '#':  case '?':
          case '<': case '>': case '"': case '`': case '\'': case ';':
          case '[': case ']': case '{': case '}': case '\\': case '|':
	    if (keep_char[(*p)&0xff]) { putchar(*p); continue; }
          case_hexa:
            printf("%%%02x", (*p)&255) ;
	    continue ;
          default:
            if (iscntrl(*p)) goto case_hexa ;
	    putchar(*p) ;
	}
	cmd = p ;
    }

    /* Terminate */
    printf("\r\nConnection: close\r\n\r\n") ;
    exit(0) ;
}

/*==================================================================
		Write to Log File
 *==================================================================*/

static void print_shell(char *text, int osh)
/*++++++++++++++++
.PURPOSE  Write the definitions of arguments (depending on the shell)
.RETURNS  ---
-----------------*/
{
  char *p ; int bol ;

    /* Remove the trailing '\n' */
    if (!text) text = "" ;
    p = text + strlen(text) - 1 ;
    if ((p >= text) && (*p == '\n')) *p = 0 ;
    /* if (ov) printf("#...print_shell[%d]\n", osh); */

    /* Initialisation */
    if (osh == Bshell) printf("set -- %s",  *text ? "" : "''"); /* Mod. V3.01 */
    if (osh == Cshell) printf("set argv = (");
    if (osh == Perl)   printf("@ARGV = (");

    for (bol=1, p=text; *p; p++) {
	if (bol) putchar('\''), bol=0 ;
	if (*p == '\n') {
	    putchar('\''), bol=1 ;
	    if (osh == Perl) putchar(',') ;
	    else putchar(' ') ;
	    continue ;
	}
	else if (*p == '\'') {
	    if (osh == Perl) printf("' . \"'\" . '") ;
	    else printf("'\"'\"'");
	    continue ;
	}
	else if ((*p == '!') && (osh == Cshell)) putchar('\\') ;
	putchar(*p) ;
    }

    /* Terminate the list of arguments */
    if (!bol) putchar('\'');
    if (osh == Cshell) putchar(')');
    if (osh == Perl)   printf(");");
    putchar('\n') ;
}

static void wlog(text, mylogfile)
/*++++++++++++++++
.PURPOSE  Write to log file --
.RETURNS  ---
.REMARKS  Use the HTTP_FROM
-----------------*/
  char *text;	/* IN: Filled buffer to write to log file */
  char *mylogfile;	/* IN: Name of logfile, or NULL   */
{
static char void_line[] = "#void#";
  int fh ;
  char buf[1024], *p, *e, *logfile ;

    if (!text) text = "(nil)";
    logfile = mylogfile;
    if (!logfile) {	/* Added V2.5 */
    	if ((!rlogfile) && (!ulogfile)) return ;
    	logfile = rlogfile ;

    	/* Decide the Local Logs or General Log */
    	/* Added Nov. 2001: NO BLANK IN HOST NAME !!! */
    	if (*remote_host) {
	    for (p = remote_host; *p; p++) { if (isspace(*p)) *p = '_'; }
    	    p = remote_host + strloc(remote_host, '.') ;
    	    if (!*p) logfile = ulogfile ;	/* Local host */
	    if (strcmp(p, ".u-strasbg.fr") == 0) logfile = ulogfile ;
    	}

    	if (!*remote_addr) logfile = ulogfile ;
    	if ((!remote_via) && (strncmp(remote_addr, "130.79.12", 9) == 0))
		logfile = ulogfile ;
    }

    /* Create the various pieces */
    buf[0] = 0;
    p = date('.') ;
    sprintf(buf, "\n----%s %sZ %ds: %s from %s",
	itext ? itext : "()", p, (int)t2000, val[REQUEST_METHOD], remote_host) ;
    p = buf + strlen(buf) ;
    if (remote_via) sprintf(p, "/via:%s", remote_via), p += strlen(p) ;
    sprintf(p, " (%s)\n", remote_addr) ;

    /* Add the HTTP USER Agent as $Agent (from Version 2.1) */
    p += strlen(p) ;
    e = val[USER_AGENT];
    if (e && (!*e)) e = (char *)0;
    if (!e) e = "---";
    val[USER_AGENT] = e;
    sprintf(p, "$AGENT: %s\n", e) ;

    if (!logfile) return ;
    fh = open(logfile, O_WRONLY|O_APPEND|O_CREAT, 0666) ;
    if (fh < 0) {
	fprintf(stderr, "****cgiparm: ");
	perror(logfile); fflush(stderr);
	return ;
    }

    if (lockf(fh, F_LOCK, 0)<0) 	/* Lock File */
	perror("#***Error lockf");
    /* V3.2: replace empty lines */
    Write(fh, buf, strlen(buf));
    p = e = text;
    while (*p == '\n') {
	void_line[sizeof(void_line)-1] = '\n';
	Write(fh, void_line, sizeof(void_line));
	p++;
    }
    while (p) {
	if ((e = strstr(p, "\n\n"))) {
	    ++e; Write(fh, p, (e-p));
	    Write(fh, void_line, sizeof(void_line)-1);
	    p = e;
	    continue;
	}
	Write(fh, p, strlen(p));
	break;
    }
    Write(fh, "\n", 1) ;
    close(fh) ;
}


/*==================================================================
		Main Program
 *==================================================================*/
#define len_arg  alen[0]
#define len_get  alen[1]
#define len_post alen[2]
#define buf_arg  abuf[0]
#define buf_get  abuf[1]
#define buf_post abuf[2]
#define np_arg   anp[0]
#define np_get   anp[1]
#define np_post  anp[2]
#define post_type atyp[2]
static char *buf_type[] = { "arg.", "get.", "post" } ;
/* post_type=0: plain file;
 * post_type=1: url-encoded (contains parameters of type name=value)
 * post_type=2: multipart */
int main(int argc, char **argv, char **envp)
{
  static char *xtyp[3] = { "no-encoding", "url-encoded", "(multipart)" };
  static int atyp[3] = { 1, 1, 1 };	/* Type for ARG/GET/POST */
  int i, n, anp[3], alen[3], bol, stat, fifo[2];
  char **a, *p, *q, *e, *abuf[3], x;
  FILE *out ;
  BUF  *com ;				/* Command for shell */
  char line[4096] ;

    if (argc < 2) {
	help();
	exit(1);
    }

    /* Get the interesting Env. Variables */
    for (i=0; i<ITEMS(env); i++) val[i] = getenv(env[i]);
    memset(anp, 0, sizeof(anp));	/* Number of parameters */
    memset(alen, 0, sizeof(alen));	/* Length of buffers    */
    memset(abuf, 0, sizeof(abuf));	/* buffers for arg/get/post */
    com = buf_alloc(0) ;

    /* Current time */
    time(&t2000);
    T = gmtime(&t2000);
    if (T->tm_year < 1000) T->tm_year += 1900;
    t2000 -= (10957*86400) ;		/* Seconds since Jan 1, 2000 */

    /* === Find out the REMOTE values === */
    if (remote_via = getenv("HTTP_FROM")) {
	p = strchr(remote_via, '@') ;		/* Skip the UserName */
	if (p) remote_via = p+1 ;
    }

    remote_host = getenv("REMOTE_HOST") ;
    if (remote_via) {
	p = remote_host ;
	remote_host = remote_via ;
	remote_via = p ;
    }

    remote_addr = getenv("REMOTE_ADDR") ;
    if (!remote_addr) remote_addr = "localhost?" ;
    if (!remote_host) remote_host = remote_addr ;

    /* Check the Options --- stop with -exec */
    while ((--argc > 0) && (!apgm)) {
	p = *++argv;
	if (*p == '-') switch(*++p) {
	    case '-':	ostdin = 1 ;
		continue ;
	    case 'h':
	        help(); exit(0);
	    case 'd':	--argc; dirName  = *++argv ;
		continue ;
	    case 'e':	/* List of programs to execute */
		apgm = ++argv ;
		continue ;
	    case 'f':	--argc; *++argv ;
		fprefix = malloc(strlen(*argv)+16);
		sprintf(fprefix, "%s%d", *argv, getpid());
		continue ;
	    case 'g':	/* Greek letters encoding */
	        if (isdigit(p[1])) greek_opt = atoi(p+1);
		else greek_opt = 1;
		continue;
	    case 'l':	--argc; ++argv ;
		rlogfile = edited_name(*argv);
		continue ;
	    case 'm':	/* Mime Types */
		mime = *++argv; --argc ;
		continue ;
	    case 'u':	--argc; ++argv;
		ulogfile = edited_name(*argv);
		continue ;
	    case 'i':	--argc; ++argv;
		if (p[1] == 'l') 	/* -ilog */
		    ilogfile = edited_name(*argv);
		else   itext = *argv;
		continue ;
	    case 'A':	/* Extract the <A HREF=...> from input */
		optA = 1 ;
		continue ;
	    case 'a':	/* Take rest of arguments as input */
		if(!val[REQUEST_METHOD]) val[REQUEST_METHOD] = "" ;
		for (a = ++argv, len_arg=0; --argc > 0; a++) {
		    np_arg++;
		    len_arg += 1 + strlen(*a) ;
		}
		buf_arg = p = malloc(1+len_arg);
		while (argv != a) {
		    if (p != buf_arg) *(p++) = '\v';
		    strcpy(p, *argv);
		    p += strlen(p) ;
		    argv++;
		}
		*p = 0;
		len_arg = strlen(buf_arg);
		continue;
	    case 'r':
	        ored = 1 ;
		continue ;
	    case 'k':
		if (isalpha(p[1]) || (!p[1])) {	/* V3.0: keep header */
		    okeep = 1;
		    continue;
		}
		keep_char[0] = 1;
		if (*++p) {	/* There is a list	*/
		    keep_char[0] = 0;
		    while(*p) keep_char[(*p)&127] = 1, p++;
		}
		continue ;
	    case 'n':	/* noname */
		oname = 0; continue;
	    case 'p':	/* -print/-praw */
		if ((p[1] == 'l') || (strcmp(p, "perl") == 0)) {
		    osh = Perl ;
		    continue ;
		}
		oprint = 1;
		if (*++p) { if (p[1] == 'a') oprint = 2 ; }
		continue;
	    case 'c':	/*  -csh  */
		if (p[1] == 'f') ocf = 1;
		else osh = Cshell;
		continue;
	    case 's':	/*   -sh  */
		osh = Bshell; continue;
	    case 'v':	/*    -v, accept -v2  */
		if (strncmp(p, "ver", 3) == 0) {	/* -version */
		    printf("cgiparm (CDS) -- version %s\n", VERSION);
		    exit(0);
		}
		if (*++p) ov = atoi(p);
		else ov   = 1;
		continue;
	}
	fprintf(stderr, "echo '****Invalid argument: %s'\n", p);
	exit(1) ;
    }
    if ((!oprint) && (!osh)) oprint = 4;

    if (ov) for (i=0; i<ITEMS(env); i++)
	printf("#...%s=%s\n", env[i], val[i] ? val[i] : "(nil)");

    /* In -- option, just read stdin and save it */
    if (ostdin) { int size, len, lines=0;
	buf_post = malloc(size=4096) ;
	buf_post[i=0] = 0;
	while(fgets(line, sizeof(line), stdin)) {
	    len = strlen(line);
	    if ((len>0) && (line[len-1] == '\n')) lines++;
	    /* Ignore HTML Comments in optA */
	    if (optA && (strncmp(line, "<!--", 4) == 0)) continue ;
	    if ((i+strlen(line)) >= size) {
		size += 4096 ;
		buf_post = realloc(buf_post, size) ;
	    }
	    strcpy(buf_post+i, line) ;
	    i += strlen(line) ;
	}
	len_post = i;
	/*post_type = is_encoded(buf_post, len_post); -- done below */
    }
    else {
        if(!val[REQUEST_METHOD]) {
	    fprintf(stderr, "echo '****REQUEST_METHOD not set'\n");
	    exit(1);
        }

	/* GET arguments: included in val[QUERY_STRING] */
	/* CAUTION: if QUERY_STRING is empty ==> buf_get remains null */
	if ((p = val[QUERY_STRING])) {
	    len_get = strlen(p);
	    buf_get = strdup(p);
	}

        /* POST method: get values from stdin */
        if (strcmp(val[REQUEST_METHOD], "POST") == 0) { int size, len=0;
	    len_post = val[CONTENT_LENGTH] ? atoi(val[CONTENT_LENGTH]) : 0;
	    size = len_post ? ((len_post+1)|7)+1 : BUFSIZ;
	    buf_post = malloc(size);
    	    if (ov) printf("#...Read %d POST bytes:\n", len_post);
	    /* V2.71: accept CONTENT_LENGTH=0 */
	    for (p=buf_post, e=buf_post+size; p<e; p += i) {
		if ((e-p)<2) {
		    size += BUFSIZ;
	            buf_post = realloc(buf_post, size);
		    p = buf_post+len; e = buf_post+size;
		}
	        i = read(0, p, e-p);
	        if (i<=0) break;
		len += i;
	        p[i] = 0;
    	        if (ov) printf("#...read %d bytes\n", i);
	    }
	    if (i<0) 	/* An error in reading */
		perror("#***Error reading POST buffer: ");
	    if (ov==2) {
		fprintf(stderr, "#...CONTENT_TYPE=\"%s\"\n",
			val[CONTENT_TYPE] ? val[CONTENT_TYPE] : "(nil)");
		fflush(stderr);
		Write(2, buf_post, len);
	    }

	    if (len != len_post) {
		fprintf(stderr, "#+++POST: read %d/%d bytes\n", len, len_post);
		if (len>len_post) { 	/* More bytes got ? */
		    if (len_post==0) len_post = len; 
		    buf_post[len_post] = 0;
		}
		else fprintf(stderr,
			"#***Missing POST input: %d/%d bytes\n",
		        len, len_post);
		len = len_post;
	    }

	    /* VERIFY the POST input is a plain file from e.g.
	       wget --post-file=file...
	       curl --data-binary
	       [  marked "application/x-www-form-urlencoded" ]
	    */
#if 0
	    if ((p = strchr(buf+qlen, '\n'))) {
		/* Is plain if more than a single line */
		if ((post_plain = p[1]));
		else while (isspace(*p) && (p>buf)) *(p--) = 0;
	    }
#endif
        }
        /* GET method: get from env.var. QUERY_STRING */
        else if ((strcmp(val[REQUEST_METHOD], "GET") == 0)
	      || (strcmp(val[REQUEST_METHOD], "HEAD") == 0)) { /*
	    buf = val[QUERY_STRING];
	    if (! buf) {
	        fprintf(stderr, "echo '****QUERY_STRING not set'\n");
	        exit(1) ;
	    }
	    len = len_get = strlen(buf); */
        }
        else if (*val[REQUEST_METHOD]){
	    fprintf(stderr, "echo \"****What's method '%s'?\"\n",
	         val[REQUEST_METHOD]);
	    exit(1);
        }
    }

    /* Interpet the GET -- it may contain a content-type... */
    if (buf_get) {
	np_get = ht_arg(buf_get);
	if (ov) printf("#...ht_arg(GET)[%d bytes]: %d\n", len_get, np_get);
	for (p=buf_get; *p; p += i) {
	    i = strloc(p, '\n'); if (i==0) { i=1; continue; }
	    if (starts_case(p, "content-type=")) break;
	}
	if (*p) {
	    p = val[CONTENT_TYPE] = strdup(p);	/* New value of Content-Type */
	    p[strloc(p, '\n')] = 0;
	    post_type = -1;	/* Indicates that the POST type is trustable */
	}
    }
    /* Decide the POST data type: encoded or not ? */
    if (buf_post) {
        if (starts_case(buf_post, "post ")) {   /* Skip the header */
	    p = buf_post + strloc(buf_post, '\n');
	    while (*p) {
	        p++;
	        if (*p == '\r') p++;
	        if (*p == '\n') { p++; break; }
	        p += strloc(p, '\n');
	    }
	    len_post = strlen(p);
	    memmove(buf_post, p, len_post+1);
        }
	if ((p = val[CONTENT_TYPE])) {
	    if (starts_by(p, "multipart/")) post_type = ENCODE_MULTIPART;
	    else if (strcmp(p, "application/x-www-form-urlencoded") == 0)
		 post_type = post_type<0 ?  /* Is trustable */
		     ENCODE_URL : is_encoded(buf_post, len_post);
	    else if (post_type<0) /* Specified by content-type,
		not multipart, and not urlencoded ==> assume PLAIN */
		post_type = ENCODE_NONE;
	    else post_type = is_encoded(buf_post, len_post);
	}
	else /* Content-Type unspecified */ {
	    post_type = is_encoded(buf_post, len_post);
	}
    }

    if (ov) printf(
	    "#---Arg.bytes: ARG=%d, GET=%d, POST=%d(%s)\n",
	    len_arg, len_get, len_post, xtyp[post_type]);

    /* Log the raw (post) input if asked */
    if (ilogfile && len_post) { int fh;
	fh = open(ilogfile, O_WRONLY|O_APPEND|O_CREAT, 0666);
	if (fh<0) {
	    fprintf(stderr, "#***writing ilogfile ");
	    perror(ilogfile);
	}
	else {
	    Write(fh, "\n(post)", 7);
	    p = date('.'); Write(fh, p, strlen(p)); Write(fh, ": ", 2);
	    Write(fh, buf_post, len_post);
	    Write(fh, "\n", 1);
	    close(fh);
	}
    }

    /* TODO : take care of arguments... */
#if 0
    if (buf_arg) {		/* From arguments */
	if (!buf) buf = buf_arg, buf_arg = (char *)0 ;
    	else {
	    len = strlen(buf_arg) ;
	    buf_arg = realloc(buf_arg, len + strlen(buf) + 2);
	    buf_arg[len] = '\v' ;	/* Concatenate, separate with VTAB */
	    strcpy(buf_arg+len+1, buf);
	    buf = buf_arg ;
	}
    }
    if (!buf) {
	fprintf(stderr, "echo \"****NO ARGUMENT to method '%s'?\"\n",
	     val[REQUEST_METHOD] ? val[REQUEST_METHOD] : "(none)");
	exit(1);
    }
    if (ov) {
	printf("#...Buffer of %d bytes <", size ? size : (int)strlen(buf));
	for (i=0; isprint(buf[i]); i++) putchar(buf[i]);
	putchar('>');
	if (i<size) printf("...");
	putchar('\n');
    }
#endif

    /* For -praw, print variables and terminate */
    /* (insert '&\n' between different arguments) */
    if (oprint == 2) {
	i = 0;
	if (len_arg) {
	    fwrite(buf_arg, len_arg, 1, stdout);
	    wlog(buf_arg, (char *)0);
	    i = len_arg;
	}
	if (len_get) {
	    if (i) printf("&\n");
	    else wlog(buf_get, (char *)0);
	    fwrite(buf_get, len_get, 1, stdout);
	    i += len_get;
	}
	if (len_post) {
	    if (i) printf("&\n");
	    else wlog(buf_post, (char *)0);
	    fwrite(buf_post, len_post, 1, stdout);
	}
	exit(0) ;
    }

    /* === -d option: Create a Directory === */
    if (dirName) {
	if (p = strchr(dirName, '%')) {
    	    if (ov) printf("#...p=%p\n", p) ;
	    e = create_dir(dirName) ;
	    if (!e) {
		fprintf(stderr, "****Can't create_dir ") ;
		perror(dirName) ;
		exit(1) ;
	    }
	    dirName = dirfile = e ;
	    chmod(e, 0755) ;
	}
	else { 		/* Just for keeping the files in multipart */
	    dirfile = dirName ; dirName = (char *)0;
	    if (!fprefix) {
		fprefix = malloc(20);
		sprintf(fprefix, "cgi%05d", getpid());
	    }
	}
    }
    if (ov) printf("#...dirName=%s, dirfile=%s\n",
	    dirName?dirName:"(nil)",
            dirfile?dirfile:"(nil)") ;

    /* Remove ending / in directories */
    if (dirfile) {
	p = dirfile + strlen(dirfile) - 1 ;
	if (*p == '/') *p = 0 ;
    }
    else if (fprefix) {	/* May contain a directory name */
	if ((p = strrchr(fprefix, '/'))) {
	    dirfile = fprefix;
	    *(p++) = 0; fprefix = p;
	}
	else dirfile = "/tmp";
    }
    else {			/* V2.72 */
	dirfile = "/tmp" ;
	fprefix = malloc(20);
	sprintf(fprefix, "cgi%05d", getpid());
    }
    if (! *dirfile) dirfile = "/tmp" ;

    if (dirName) {
	p = dirName + strlen(dirName) - 1 ;
	if (*p == '/') *p = 0 ;
    }

    if (ov) printf("#...dirName=%s, dirfile=%s\n",
	    dirName?dirName:"(nil)",
            dirfile?dirfile:"(nil)") ;

    /* ------- MULTIPART or older Methods:: Get parameters */
    /* Example of MULTIPART:
       CONTENT_TYPE=multipart/form-data; boundary=---------------------------13
       REQUEST_METHOD=POST
       -----------------------------13
       Content-Disposition: form-data; name="radio"

       value
       -----------------------------13
       Content-Disposition: form-data; name="pics"; filename="tmp"
       Content-Type: ...

       (contents of file transferred)

    */
    if (optA) { /* Get only the HREF contents */
	if (buf_arg) tr_optA(buf_arg) ;
	if (buf_get) tr_optA(buf_get) ;
	if (buf_post) tr_optA(buf_post) ;
	/*np = ht_arg(buf_arg) + ht_arg(buf_get) + ht_arg(buf_post);*/
    }
    if (post_type == ENCODE_MULTIPART) {
        p = val[CONTENT_TYPE];	/* CONTENT_TYPE only for POST part */
	if (strncmp(p, "multipart/", 10) == 0) {
	    p += strloc(p, ';') ;
	    p += strloc(p, '=') ;
	    if (strncmp(p-8, "boundary=", 9) == 0) p++ ;
	    else p = (char *)0 ;
	    np_post = get_multipart(buf_post, len_post, p) ;
	    post_type = 1;	/* Now a param=value file */
	    oname = 1 ;		/* Name ignore done in get_multipart 	*/
	}
	else {
	    fprintf(stderr, "#***multipart without CONTENT_TYPE:\n");
	    fprintf(stderr, "%s\n", buf_post);
	}
    }
    else if (post_type && buf_post) {
	/* Just assume the standard url-encoded */
	np_post = ht_arg(buf_post);
    }
    /*else if (buf_post) np_post = ht_arg(buf_post);*/
    if (ov) {
	printf("#---Arguments: %d + %d + %d = %d\n",
	    anp[0], anp[1], anp[2], anp[0]+anp[1]+anp[2]);
    }
    /* Maybe we need several decodings (GET only)?
     * Notice: mplus=1 when -plus=%... found, meaning that
     * the recursivity level was set in ht_arg.
     */
    if ((!mplus) && (buf_get)) {
	while (is_encoded(buf_get, len_get)) {
	    keep_char['\n'] = 1;
	    np_get = ht_arg(buf_get);
	}
    }

#if 0 /* V3.4: SECURE no /etc/ */
    if ((p=strstr(buf, "/etc/"))) {
	fprintf(stderr, "#***cgiparm*/etc/* from %s\n",
		remote_addr ? remote_addr : "(nil_remote)");
	for (a=envp; *a; a++) fprintf(stderr, "#[env]%s\n", *a);
	exit(1);
    }
#else /* V3.6 */
    for (i=0; i<ITEMS(abuf); i++) {
	if (!abuf[i]) continue;
	if (check_buf(abuf[i], 0)>=2) {
	    fprintf(stderr, "#***cgiparm*/etc/*[%s] rejected\n",
	        remote_addr ? remote_addr : "(nil_remote)");
	    for (a=envp; *a; a++) fprintf(stderr, "#[env]%s\n", *a);
	    exit(1);
	}
    }
#endif

    /* Verify the Redirect if asked for */
    if (ored) for (i=0; i<ITEMS(abuf); i++) {
	if (abuf[i]) abuf[i] = greek_subs(abuf[i]);
        redirect_if(abuf[i]) ;
    }

#if 0 /* done in check_buf */
    /* V2.82: Remove the possible <script> directives!!! */
    for (p=strchr(buf, '<'); p; p=strchr(p, '<')) {
	if (strncasecmp(p, "<script", 7) == 0) *p = '#';
	else p++;
    }
#else
    for (i=0; i<ITEMS(abuf); i++) {
	if (!abuf[i]) continue;
	if (ov) {
	    if ((p = strchr(abuf[i], '\n'))) { int nl=0;
		while ((p = strchr(p, '\n'))) { nl++; p++; }
		printf("#...cgiparm(%s): %d lines\n", buf_type[i], nl);
		printf("%s\n", abuf[i]);
	    }
	    else printf("#...cgiparm(%s): %s\n", buf_type[i], abuf[i]);
	}
        if (check_buf(abuf[i], 1)) {
            fprintf(stderr, "#+++cgiparm[%s] commented <script>\n",
	        remote_addr ? remote_addr : "(nil_remote)");
	}
    }
#endif

    /* No redirection here. Issue the standard HTML headers */
    if (mime) {
	printf("Content-type: %s\r\n", mime) ;
	/* Propose also the output file name */
	if (input_filenames[0]) {
	    p = input_filenames[0];
	    p += strloc(p, '\n');
	    e = p;
	    while (*--p != '=') {
		if (*p == '.') e = p;	/* Indicates file extension */
		if (*p == '/') break;
		if (*p == '\\') break;
	    }
	    printf("Content-Disposition: inline; filename=\"");
	    for (++p; p<e; p++) putchar(*p);
	    /* Which extension ? */
	    for (a=mime_ext; *a; a+=2) {
		if (strstr(mime, *a)) break;
	    }
	    /* Be sure the extension is different! */
	    if (*a) {
		p = a[1];
		if (strncmp(p, e, strlen(p)) == 0) p = (char *)0;
	    }
	    else p = (char *)0;
	    if (p) printf("%s", p);
	    else {		/* Propose an additional extension */
		while (isgraph(*e)) putchar(*e), e++;
		printf(".viz");
	    }
	    printf("\"\r\n");
	}
	printf("\r\n\r\n");
    }

    /* V1.8: Remove some Unicode elements */
    if (!keep_char[0]) for (i=0; i<ITEMS(abuf); i++) {
	if (!abuf[i]) continue;
	if (greek_opt) {
	    n = strumb1(abuf[i]);
	    if (ov && n) printf(
		"#..There were %d UTF8-multibyte symbols replaced.\n", n);
            abuf[i] = greek_subs(abuf[i]);
	}
    }

    /* IF redirections are required, FORK */
    if (apgm) {
       	fflush(stdout) ;
       	if (pipe(fifo)) { perror("****Can't pipe from cgiparm"); exit(1); }
       	/* Copy the argument addresses to new locations */
       	argv = apgm ;		/* Old argument location */
       	for (a=argv; (--argc > 0) && strcmp(*a, ";") ; a++) ;
       	i = (a - argv) ;		/* Number of -exec arguments */
       	a = apgm = (char **)malloc(i+2) ;
       	*(a++) = "pip2" ; 	/* This program executes pipes */
       	while (--i >= 0) *(a++) = *(argv++) ;
       	*a = (char *)0 ;

       	stat = vfork() ;
       	if (stat == -1) { 	/* FAIL  */
	    perror("****Can't fork from cgiparm");
	    exit(1);
	}
	if (stat == 0) {	/* CHILD */
	   close(fifo[1]);	/* Side used by parent */
	   close(0) ;
	   if (dup(fifo[0])<0) perror("****CHILD dup() FAILED");
	   close(fifo[0]);
	   /* printf("----CHILD, execute %s %s...\n", *apgm, apgm[1]) ; */
	   execvp(*apgm, apgm) ;
	   perror("****CHILD FAILED") ;
	   exit(127); 	/* NEVER REACHED */
	}

	/* Here the father terminates its jobs */
	close(fifo[0]);	/* Side used by child */
	dup2(fifo[1], 1); ;
	close(fifo[1]);
   }

   /* Remove names if asked for */
    if (! oname) { int ibuf, len;
	if (input_filenames[0] && ocf) ocf = 0, fprintf(stderr,
	    "++++Can't keep file names when names are removed!\n");
        for (ibuf=0; ibuf<ITEMS(abuf); ibuf++) {
	    p=q=abuf[ibuf]; if (!p) continue;
	    while (*p) {
	        if (*p == '\n') { *(q++) = *(p++); continue ; }
                len = strloc(p, '\n');
                i   = strloc(p, '=');
                if (i < len) p += i+1, len -= i+1;
	        while (--len >= 0) *(q++) = *(p++) ;
	    }
	    *q = 0 ;
            if (ov) printf(
		"#...The %d arguments without names:\n%s\n",
		anp[ibuf], abuf[ibuf]);
        }
    }

    /* Write the filenames found */
    if (ocf) for (a=input_filenames; *a; a++) { int len;
	p = *a;
	len = strloc(p, '\n');
	i = p[len]; p[len] = 0;
	printf(":%s\n", p);
	p[len] = i;
    }

#if 0
    /* Write out if -print asked for */
    if (oprint & 1) {
    	if (ov) printf("----print result:\n");
        for (i=0; i<ITEMS(abuf); i++) {
	    if (abuf[i]) printf("%s\n", abuf[i]);
	}
    }
    /*if (ov) printf("----Value of buf:\n%s\n", buf) ;*/
#endif

    /* Define as a set of Arguments; be careful, quotes are
	escaped with "'" ; create temporary files if needed.
    */
    out = (FILE *)0 ; e = (char *)0 ;
    if ((oprint) || (osh /*&& *buf*/)) { int ibuf, np;
    	if (ov) printf("#---result (print/sh):\n");
        bol = 1 ; np = 0 ;
	if (dirName) {	/* Argument -d= */
	    if (oprint&1) printf("-d=%s\n", dirName);
	    else {
		append(com, "-d=");
		append(com, dirName);
		append(com, "\n");
	    }
	    np++;
	}
        for (ibuf=0; ibuf<ITEMS(abuf); ibuf++) {
	  if (!abuf[ibuf]) continue;
	  if (ov) printf("#...buf_%s: type=%d(%s): %d bytes\n",
		  buf_type[ibuf], atyp[ibuf], xtyp[atyp[ibuf]], alen[ibuf]);
	  /* Write an output file ONLY IF both POST + GET arguments */
	  if ((atyp[ibuf] == 0) && (ibuf==2) && ((alen[0]+alen[1])>0)) {
	    /* Simple file */
	    out = open_file("");	/* Default name */
	    if (!out) exit(1);
	    fwrite(abuf[ibuf], 1, alen[ibuf], out);
	    fclose(out);
	    append(com, "-file=");
	    append(com, opened_file) ;
	    append1(com, '\n') ;
	    out = (FILE *)0;
	    np++;
	    continue;
	  }

	  if (oprint&1) {
	      printf("%s\n", abuf[ibuf]);
	      if (osh==0) continue;
	  }
	  /* Here the buffer contains a 'name=value' set (type==1) */
	  e = (char *)0;
	  for (p=abuf[ibuf]; *p; p++) {
	    if (e) {	/* Within output file, bol == 1	*/
	      int len;
		len = strloc(p, '\n') ;
		if (strncmp(p, e, len+1) == 0) {
		    if (out) fclose(out) ;
		    out = (FILE *)0 ;
		    e = (char *)0 ;
		}
		else if (out) fwrite(p, 1, len+1, out) ;
		p += len ;
		continue ;
	    }
	    if (*p == '\n') { bol = 1; append1(com, *p); continue; }
	    if (bol) {	/* Beginning of Line, no out	*/
	      int len;
		len = strloc(p, '\n') ; i = strloc(p, '=') ;
		if ((i<len) && (strncmp(p+i, "=<<==", 5) == 0)) {
		    e = p + i + 3;	/* End Marker (sentinel) */
		    if (dirName) {	/* Create in dedicated Directory */
			stat = p[len] ; p[len] = 0 ;
			if (e[4]) out = open_file(basename(e+4)) ;
			p[len] = stat ;
		    }
		    else out = open_file("") ;	/* Defaut Name */
		    if (out) {			/* file: use -c=file:filename */
			x = p[i+1] ; p[i+1] = 0 ;
			append(com, p) ; if (!dirName) append(com, "file:");
		        append(com, opened_file) ;
			append1(com, '\n') ;
			p[i+1] = x ;
			if ((!dirName) && e[4]) {   /* Add the original name */
			  int j, d;
			    x = p[i]; p[i]=0;
			    append(com, p) ; append(com, ":file=");
			    p[i]=x;
			    j = com->used;	/* To remove the # */
			    x = p[len]; p[len] = 0;
			    append(com, basename(e+4));
			    p[len] = x;
			    d = strloc(com->buf+j, '#');
			    if (com->buf[d+j] == '#') {
				com->buf[d+j] = 0;
				com->used = d+j;
			    }
			    append1(com, '\n') ;
			}
		    }
		    p += len ;	/* Here p->'\n' */
#if 0		    /* V3.1: remove nContent-Type */
		    if (strncmp(p, file_header, sizeof(file_header)-1) == 0) {
			i = strloc(p+1, '\n')+1;
			if ((p[i] == '\n') && (iscntrl(p[i+1])))
			    p += i;
		    }
#endif
		    /* V3.6: Write out the binary file contents */
		    if(out) {
			if ((len = bin_len(e,0))) {
			    p++; 	/* p->beginning of bin contents */
    			    if (ov) printf("#===Write %s: %d bytes.\n",
				opened_file, len);
			    fwrite(p, 1, len, out);
			}
			fclose(out);
			out = (FILE *)0;
			if (len == 0) { 	/* V3.71: remove empty file */
			    unlink(opened_file);
			}
			p += len;
			/* ... and skip the sentinel */
			if (*p == '\n') p++;
			while ((*p == *e) && (*p != '\n')) { p++; e++; }
			if (*p == '\n') --p;
			e = (char *)0;
			continue;
		    }
		    continue ;
		}   /* End of included file */
		bol = 0 ;
		np++ ;
	    }
#if 0
	    if (osh) append1(com, *p) ;
	    if (oprint&4) {	/* -f option */
		if (!out) out = open_file(dirName ? "0" : (char *)0) ;
		fputc(*p, out) ;
	    }
#else
	    append1(com, *p);
#endif
	    if (*p == '\n') bol = 1 ;
    	  }
	  if (out) { fclose(out); out = (FILE *)0; }
	  if ((!bol) && (com->used)) append1(com, '\n') ;
#if 0
	  /* Write out the PLAIN file */
	  /* First argument is -file= */
	  if (post_type) {
	    out = open_file("");	/* Default name */
	    if (!out) exit(1);
	    fwrite(buf+qlen, 1, len_post, out);
	    fclose(out);
	    if (osh && out) { char *text;
		text = com->buf ? strdup(com->buf) : (char *)0;
		com->used = 0;
		append(com, "-file=");
		append(com, opened_file) ;
		append1(com, '\n') ;
		if (text) { 	/* Problem: don't accept a -file argument */
		    if ((p = strstr(text, "-file="))) {
			if ((p==text) || (p[-1] == '\n')) *p = '#';
		    }
		    append(com, text);
		    free(text);
		}
	    }
	  }
#endif
	}
    }
    /* Write out the Directory Name */
    if (oprint&(1|4)) {
#if 0
	append(com, "-d=") ;
	append(com, dirfile) ;
	if (!dirName) append(com, "/p"), append(com, i2a(getpid())) ;
	append1(com, '\n') ;
#else
	if (com->used) printf("%s\n", com->buf);
#endif
    }
    if (ov) {
	printf("#...%-6s => ", "Bshell"); print_shell(com->buf, Bshell);
	printf("#...%-6s => ", "Cshell"); print_shell(com->buf, Cshell);
	printf("#...%-6s => ", "Perl");   print_shell(com->buf, Perl);
    }
    if (osh) print_shell(com->buf, osh) ;
    p = dirName? com->buf : abuf[1];
    if (!p) p = abuf[2];
    if (!p) p = abuf[0];
    wlog(p, (char *)0) ;
    exit(0);
}
